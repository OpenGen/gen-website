<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS --> 
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous">
    <link rel="stylesheet" href="/assets/css/styles.css">

    <!-- MathJax -->
<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  },
  svg: {
    fontCache: 'global'
  }
};
</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <title>Reasoning about Regenerate</title>
  </head>
  <body>
    
    <header class="navbar navbar-expand navbar-dark flex-column flex-md-row bd-navbar">
  <a class="navbar-brand mr-0 mr-md-2" href="/" aria-label="Gen">
<svg version="1.1" width="36" height="36" viewBox="0.0 0.0 433.7244094488189 432.76640419947506" fill="none" stroke="none" stroke-linecap="square" stroke-miterlimit="10" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg"><clipPath id="p.0"><path d="m0 0l433.7244 0l0 432.76642l-433.7244 0l0 -432.76642z" clip-rule="nonzero"/></clipPath><g clip-path="url(#p.0)"><path fill="#000000" fill-opacity="0.0" d="m0 0l433.7244 0l0 432.76642l-433.7244 0z" fill-rule="evenodd"/><path fill="#000000" fill-opacity="0.0" d="m526.3617 215.97453l0 0c0 -112.37038 91.09418 -203.46457 203.4646 -203.46457l0 0c53.96216 0 105.71411 21.436382 143.87115 59.593395c38.156982 38.157005 59.593384 89.90901 59.593384 143.87117l0 0c0 112.37038 -91.09418 203.46455 -203.46454 203.46455l0 0c-112.37042 0 -203.4646 -91.09418 -203.4646 -203.46455z" fill-rule="evenodd"/><path stroke="#ffffff" stroke-width="16.0" stroke-linejoin="round" stroke-linecap="butt" d="m526.3617 215.97453l0 0c0 -112.37038 91.09418 -203.46457 203.4646 -203.46457l0 0c53.96216 0 105.71411 21.436382 143.87115 59.593395c38.156982 38.157005 59.593384 89.90901 59.593384 143.87117l0 0c0 112.37038 -91.09418 203.46455 -203.46454 203.46455l0 0c-112.37042 0 -203.4646 -91.09418 -203.4646 -203.46455z" fill-rule="evenodd"/><path fill="#000000" fill-opacity="0.0" d="m95.40751 8.810548l290.11023 0l0 288.18896l-290.11023 0z" fill-rule="evenodd"/><path fill="#ffffff" d="m308.04813 300.89618q-12.859375 15.421875 -36.375 23.921875q-23.5 8.484375 -52.09375 8.484375q-30.03125 0 -52.671875 -13.09375q-22.625 -13.109375 -34.9375 -38.046875q-12.312492 -24.9375 -12.624992 -58.625l0 -15.71875q0 -34.640625 11.671867 -59.96875q11.671875 -25.34375 33.671875 -38.765625q22.0 -13.421875 51.546875 -13.421875q41.140625 0 64.328125 19.625q23.203125 19.609375 27.484375 57.109375l-46.375 0q-3.171875 -19.859375 -14.0625 -29.0625q-10.875 -9.21875 -29.9375 -9.21875q-24.3125 0 -37.015625 18.265625q-12.703125 18.265625 -12.875 54.328125l0 14.765625q0 36.375 13.8125 54.96875q13.828125 18.578125 40.515625 18.578125q26.859375 0 38.296875 -11.4375l0 -39.875l-43.375 0l0 -35.09375l91.015625 0l0 92.28125z" fill-rule="nonzero"/><path fill="#000000" fill-opacity="0.0" d="m20.661194 84.271866l0 0c0 -36.022438 29.201962 -65.224396 65.2244 -65.224396l260.8898 0l0 0c17.298584 0 33.88864 6.8718376 46.120605 19.103786c12.231934 12.231945 19.10379 28.82203 19.10379 46.120613l0 260.88977c0 36.02243 -29.201965 65.224396 -65.224396 65.224396l-260.8898 0c-36.02244 0 -65.2244 -29.201965 -65.2244 -65.224396z" fill-rule="evenodd"/><path stroke="#ffffff" stroke-width="24.0" stroke-linejoin="round" stroke-linecap="butt" d="m20.661194 84.271866l0 0c0 -36.022438 29.201962 -65.224396 65.2244 -65.224396l260.8898 0l0 0c17.298584 0 33.88864 6.8718376 46.120605 19.103786c12.231934 12.231945 19.10379 28.82203 19.10379 46.120613l0 260.88977c0 36.02243 -29.201965 65.224396 -65.224396 65.224396l-260.8898 0c-36.02244 0 -65.2244 -29.201965 -65.2244 -65.224396z" fill-rule="evenodd"/></g></svg>
</a>
  <div class="navbar-nav-scroll">
    <ul class="navbar-nav bd-navbar-nav flex-row">
    
      <li class="nav-item">
        <a class="nav-link " href="/">Home</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-link " href="https://www.gen.dev/dev/">Documentation</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-link " href="/tutorials/">Tutorials</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-link " href="https://github.com/probcomp/Gen.jl">Source</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-link " href="/ecosystem/">Ecosystem</a>
      </li>
    
    </ul>
  </div>

</header>



<main role="main">
    <br/>
<div class="container">
<h1 id="reasoning-about-regenerate">Reasoning About Regenerate</h1>

<p>Gen provides a primitive called <a href="https://probcomp.github.io/Gen/dev/ref/gfi/#Regenerate-1"><code class="language-plaintext highlighter-rouge">regenerate</code></a> that allows users to ask for certain random choices in a trace to be re-generated from scratch. <code class="language-plaintext highlighter-rouge">regenerate</code> is the basis of one variant of the <a href="https://probcomp.github.io/Gen/dev/ref/inference/#Gen.metropolis_hastings"><code class="language-plaintext highlighter-rouge">metropolis_hastings</code></a> operator in Gen’s inference library.</p>

<p>This notebook aims to help you understand the computation that <code class="language-plaintext highlighter-rouge">regenerate</code> is performing.</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="n">Gen</span><span class="o">:</span> <span class="n">bernoulli</span><span class="x">,</span> <span class="nd">@gen</span>
</code></pre></div></div>

<p>Let’s start by defining a simple generative function:</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@gen</span> <span class="k">function</span><span class="nf"> foo</span><span class="x">(</span><span class="n">prob_a</span><span class="x">)</span>
    <span class="n">val</span> <span class="o">=</span> <span class="nb">true</span>
    <span class="k">if</span> <span class="x">({</span><span class="o">:</span><span class="n">a</span><span class="x">}</span> <span class="o">~</span> <span class="n">bernoulli</span><span class="x">(</span><span class="n">prob_a</span><span class="x">))</span>
        <span class="n">val</span> <span class="o">=</span> <span class="x">({</span><span class="o">:</span><span class="n">b</span><span class="x">}</span> <span class="o">~</span> <span class="n">bernoulli</span><span class="x">(</span><span class="mf">0.6</span><span class="x">))</span> <span class="o">&amp;&amp;</span> <span class="n">val</span>
    <span class="k">end</span>
    <span class="n">prob_c</span> <span class="o">=</span> <span class="n">val</span> <span class="o">?</span> <span class="mf">0.9</span> <span class="o">:</span> <span class="mf">0.2</span>
    <span class="n">val</span> <span class="o">=</span> <span class="x">({</span><span class="o">:</span><span class="n">c</span><span class="x">}</span> <span class="o">~</span> <span class="n">bernoulli</span><span class="x">(</span><span class="n">prob_c</span><span class="x">))</span> <span class="o">&amp;&amp;</span> <span class="n">val</span>
    <span class="k">return</span> <span class="n">val</span>
<span class="k">end</span><span class="x">;</span>
</code></pre></div></div>

<p>Recall the distribution on choice maps for this generative function:</p>

\[\begin{array}{l|l|l}
\mbox{Random choice map } t &amp; \mbox{Probability } p(t; x) &amp; \mbox{Return value } f(x, t) \\
\hline
\{a \mapsto \mbox{true}, b \mapsto \mbox{true}, c \mapsto \mbox{true}\} &amp; \mbox{prob_a} \cdot 0.6\cdot 0.9 &amp; \mbox{true}\\
\{a \mapsto \mbox{true}, b \mapsto \mbox{true}, c \mapsto \mbox{false}\} &amp; \mbox{prob_a} \cdot 0.6 \cdot 0.1 &amp; \mbox{false}\\
\{a \mapsto \mbox{true}, b \mapsto \mbox{false}, c \mapsto \mbox{true}\} &amp; \mbox{prob_a} \cdot 0.4 \cdot 0.2 &amp; \mbox{false}\\
\{a \mapsto \mbox{true}, b \mapsto \mbox{false}, c \mapsto \mbox{false}\} &amp; \mbox{prob_a} \cdot 0.4 \cdot 0.8 &amp; \mbox{false}\\
\{a \mapsto \mbox{false}, c \mapsto \mbox{true}\} &amp; (1-\mbox{prob_a}) \cdot 0.9 &amp; \mbox{true}\\
\{a \mapsto \mbox{false}, c \mapsto \mbox{false}\} &amp; (1-\mbox{prob_a}) \cdot 0.1 &amp; \mbox{false}
\end{array}\]

<p>Let’s first obtain an initial trace with ${a \mapsto \mbox{true}, b \mapsto \mbox{false}, c \mapsto \mbox{true}}$, using <code class="language-plaintext highlighter-rouge">generate</code>:</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="n">Gen</span><span class="o">:</span> <span class="n">generate</span><span class="x">,</span> <span class="n">choicemap</span>

<span class="n">trace</span><span class="x">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">generate</span><span class="x">(</span><span class="n">foo</span><span class="x">,</span> <span class="x">(</span><span class="mf">0.3</span><span class="x">,),</span> <span class="n">choicemap</span><span class="x">((</span><span class="o">:</span><span class="n">a</span><span class="x">,</span> <span class="nb">true</span><span class="x">),</span> <span class="x">(</span><span class="o">:</span><span class="n">b</span><span class="x">,</span> <span class="nb">false</span><span class="x">),</span> <span class="x">(</span><span class="o">:</span><span class="n">c</span><span class="x">,</span> <span class="nb">true</span><span class="x">)));</span>
</code></pre></div></div>

<p>Now, we ask for the value at address <code class="language-plaintext highlighter-rouge">:a</code> to be re-generated:</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="n">Gen</span><span class="o">:</span> <span class="n">regenerate</span><span class="x">,</span> <span class="n">select</span><span class="x">,</span> <span class="n">NoChange</span>
<span class="x">(</span><span class="n">trace</span><span class="x">,</span> <span class="n">weight</span><span class="x">,</span> <span class="n">retdiff</span><span class="x">)</span> <span class="o">=</span> <span class="n">regenerate</span><span class="x">(</span><span class="n">trace</span><span class="x">,</span> <span class="x">(</span><span class="mf">0.3</span><span class="x">,),</span> <span class="x">(</span><span class="n">NoChange</span><span class="x">(),),</span> <span class="n">select</span><span class="x">(</span><span class="o">:</span><span class="n">a</span><span class="x">));</span>
</code></pre></div></div>

<p>Note that unlike <a href="https://probcomp.github.io/Gen/dev/ref/gfi/#Gen.update"><code class="language-plaintext highlighter-rouge">update</code></a>, we do not provide the new values for the random choices that we want to change. Instead, we simply pass in a <a href="https://probcomp.github.io/Gen/dev/ref/selections/#Selections-1">selection</a> indicating the addresses that we want to propose new values for.</p>

<p>Note that <code class="language-plaintext highlighter-rouge">select(:a)</code> is equivalent to:</p>
<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">selection</span> <span class="o">=</span> <span class="n">DynamicAddressSet</span><span class="x">()</span>
<span class="n">push!</span><span class="x">(</span><span class="n">selection</span><span class="x">,</span> <span class="o">:</span><span class="n">a</span><span class="x">)</span>
</code></pre></div></div>

<p>We print the choices in the new trace:</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="n">Gen</span><span class="o">:</span> <span class="n">get_choices</span>

<span class="n">get_choices</span><span class="x">(</span><span class="n">trace</span><span class="x">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>│
├── :a : false
│
└── :c : true
</code></pre></div></div>

<p>Re-run the regenerate command until you get a trace where <code class="language-plaintext highlighter-rouge">a</code> is <code class="language-plaintext highlighter-rouge">false</code>. Note that the address <code class="language-plaintext highlighter-rouge">b</code> doesn’t appear in the resulting trace. Then, run the command again until you get a trace where <code class="language-plaintext highlighter-rouge">a</code> is <code class="language-plaintext highlighter-rouge">true</code>. Note that now there is a value for <code class="language-plaintext highlighter-rouge">b</code>. This value of <code class="language-plaintext highlighter-rouge">b</code> was sampled along with the new value for <code class="language-plaintext highlighter-rouge">a</code>—<code class="language-plaintext highlighter-rouge">regenerate</code> will regenerate new values for the selected adddresses, but also any new addresses that may be introduced as a consequence of stochastic control flow.</p>

<p>What distribution is <code class="language-plaintext highlighter-rouge">regenerate</code> sampling the selected values from? It turns out that <code class="language-plaintext highlighter-rouge">regenerate</code> is using the <a href="https://probcomp.github.io/Gen/dev/ref/gfi/#.-Internal-proposal-distribution-family-1"><em>internal proposal distribution family</em></a> $q(t; x, u)$, just like like <code class="language-plaintext highlighter-rouge">generate</code>. Recall that for <code class="language-plaintext highlighter-rouge">@gen</code> functions, the internal proposal distribution is based on <em>ancestral sampling</em>.  But whereas <code class="language-plaintext highlighter-rouge">generate</code> was given the expicit choice map of constraints ($u$) as an argument, <code class="language-plaintext highlighter-rouge">regenerate</code> constructs $u$ by starting with the previous trace $t$ and then removing any selected addresses. In other words, <code class="language-plaintext highlighter-rouge">regenerate</code> is like <code class="language-plaintext highlighter-rouge">generate</code>, but where the constraints are the choices made in the previous trace less the selected choices.</p>

<p>We can make this concrete. Let us start with a deterministic trace again:</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">trace</span><span class="x">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">generate</span><span class="x">(</span><span class="n">foo</span><span class="x">,</span> <span class="x">(</span><span class="mf">0.3</span><span class="x">,),</span> <span class="n">choicemap</span><span class="x">((</span><span class="o">:</span><span class="n">a</span><span class="x">,</span> <span class="nb">true</span><span class="x">),</span> <span class="x">(</span><span class="o">:</span><span class="n">b</span><span class="x">,</span> <span class="nb">false</span><span class="x">),</span> <span class="x">(</span><span class="o">:</span><span class="n">c</span><span class="x">,</span> <span class="nb">true</span><span class="x">)));</span>
</code></pre></div></div>

<h3 id="understanding-how-regenerate-constructs-the-internal-proposal-distribution-family">Understanding how regenerate constructs the internal proposal distribution family</h3>

<p>We will run <code class="language-plaintext highlighter-rouge">regenerate</code> with a selection of just <code class="language-plaintext highlighter-rouge">:a</code>. Let’s analyze the internal proposal distribution in this case:</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="x">(</span><span class="n">trace</span><span class="x">,</span> <span class="n">weight</span><span class="x">,</span> <span class="n">retdiff</span><span class="x">)</span> <span class="o">=</span> <span class="n">regenerate</span><span class="x">(</span><span class="n">trace</span><span class="x">,</span> <span class="x">(</span><span class="mf">0.3</span><span class="x">,),</span> <span class="n">noargdiff</span><span class="x">,</span> <span class="n">select</span><span class="x">(</span><span class="o">:</span><span class="n">a</span><span class="x">));</span>
</code></pre></div></div>

<p>Since the current trace is $t = {a \mapsto \mbox{true}, b \mapsto \mbox{false}, c \mapsto \mbox{true}}$, the constraints $u$ that will be passed to the internal proposal are $u = {b \mapsto \mbox{false}, c \mapsto \mbox{true}}$ (everything in $t$ but with the mapping for any selected addresses removed).</p>

<p>To compute the internal proposal distribution, we first write down the list of all choice maps $t’$ where $p(t’; x) &gt; 0$, with the probability $p(t’; x)$ listed.</p>

\[\begin{array}{l|l}
\mbox{Random choice map } t' &amp; \mbox{Probability } p(t'; x)\\
\hline
\{a \mapsto \mbox{true}, b \mapsto \mbox{true}, c \mapsto \mbox{true}\} &amp; 0.3 \cdot 0.6\cdot 0.9\\
\{a \mapsto \mbox{true}, b \mapsto \mbox{true}, c \mapsto \mbox{false}\} &amp; 0.3 \cdot 0.6 \cdot 0.1\\
\{a \mapsto \mbox{true}, b \mapsto \mbox{false}, c \mapsto \mbox{true}\} &amp; 0.3 \cdot 0.4 \cdot 0.2\\
\{a \mapsto \mbox{true}, b \mapsto \mbox{false}, c \mapsto \mbox{false}\} &amp; 0.3 \cdot 0.4 \cdot 0.8\\
\{a \mapsto \mbox{false}, c \mapsto \mbox{true}\} &amp; 0.7 \cdot 0.9\\
\{a \mapsto \mbox{false}, c \mapsto \mbox{false}\} &amp; 0.7 \cdot 0.1
\end{array}\]

<p>Then, we eliminate any choice maps $t’$ such that $t’(i) \ne u(i)$ for some address $i$ that is contained in both maps $u$ and $t’$.</p>

<p>In particular:</p>

<ul>
  <li>
    <p>we eliminate $t’ = {a \mapsto \mbox{true}, b \mapsto \mbox{true}, c \mapsto \mbox{true}}$ because $t’(b) = \mbox{true} \ne u(b) = \mbox{false}$.</p>
  </li>
  <li>
    <p>we eliminate $t’ = {a \mapsto \mbox{true}, b \mapsto \mbox{true}, c \mapsto \mbox{false}}$ because $t’(c) = \mbox{false} \ne u(c) = \mbox{true}$.</p>
  </li>
  <li>
    <p>we eliminate $t’ = {a \mapsto \mbox{true}, b \mapsto \mbox{false}, c \mapsto \mbox{false}}$ because $t’(c) = \mbox{false} \ne u(c) = \mbox{true}$.</p>
  </li>
  <li>
    <p>we eliminate $t’ = {a \mapsto \mbox{false}, c \mapsto \mbox{false}}$ because $t’(c) = \mbox{false} \ne u(c) = \mbox{true}$.</p>
  </li>
</ul>

<p>For the remaining choice maps $t’$ we require that $q(t’; x, u) &gt; 0$. The remaining two choice maps are:</p>

\[\begin{array}{l}
t' = \{a \mapsto \mbox{true}, b \mapsto \mbox{false}, c \mapsto \mbox{true}\}\\
t' = \{a \mapsto \mbox{false}, c \mapsto \mbox{true}\}
\end{array}\]

<p>The ancestral sampling algorithm has two possible results, depending on whether the new value for <code class="language-plaintext highlighter-rouge">a</code> was <code class="language-plaintext highlighter-rouge">true</code> or <code class="language-plaintext highlighter-rouge">false</code>. It will sample <code class="language-plaintext highlighter-rouge">a = true</code> with probability 0.3 and <code class="language-plaintext highlighter-rouge">a = false</code> with probability 0.7. If <code class="language-plaintext highlighter-rouge">a</code> is sampled to be <code class="language-plaintext highlighter-rouge">true</code>, then the existing value of <code class="language-plaintext highlighter-rouge">b = false</code> will always be kept. In both cases, the previous value of <code class="language-plaintext highlighter-rouge">c = true</code> is kept. Therefore, the internal proposal distribution is:</p>

\[\begin{array}{l|l}
\mbox{Random choice map } t' &amp; q(t'; x, u)\\
\hline
\{a \mapsto \mbox{true}, b \mapsto \mbox{false}, c \mapsto \mbox{true}\} &amp; 0.3\\
\{a \mapsto \mbox{false}, c \mapsto \mbox{true}\} &amp; 0.7
\end{array}\]

<h3 id="reversibility-of-regenerate">Reversibility of regenerate</h3>

<p>Regenerate has the useful property, that for selected addresses $I$ (e.g. $I = {a}$) and initial choice map $t$ where $p(t; x) &gt; 0$, if regenerate has nonzero probability of producing a new choice map $t’$ from $t$ and $I$, then regenerate also has a nonzero probability of producing choice map $t$ from $t’$ and the same set of selected addresses $I$.</p>

<p><em>Challenge: convince yourself, or prove, that this is the case.</em></p>

<h3 id="understanding-the-weight-returned-by-regenerate">Understanding the weight returned by regenerate</h3>

<p>The weight returned by <code class="language-plaintext highlighter-rouge">regenerate</code>, for selected addresses $I$ is:</p>

\[\log \frac{p(t'; x')q(t; u', x)}{p(t; x) q(t'; u, x')}\]

<p>where $u$ is the restriction of $t$ to the complement of $I$, and where $u’$ is the restriction of $t’$ to the complement of $I$.</p>

<p>We will now manually compute what the weights should be for the two possible transitions from $t = {a \mapsto \mbox{true}, b \mapsto \mbox{false}, c \mapsto \mbox{true}}$, with $I = {a}$.</p>

<p>First, consider $t’ = {a \mapsto \mbox{true}, b \mapsto \mbox{false}, c \mapsto \mbox{true}}$. In this case, $u’ = {b \mapsto \mbox{false}, c \mapsto \mbox{true}}$. The internal proposal distribution in this case is:</p>

\[\begin{array}{l|l}
\mbox{Random choice map }t &amp; q(t; x, u')\\
\hline
\{a \mapsto \mbox{true}, b \mapsto \mbox{false}, c \mapsto \mbox{true}\} &amp; 0.3\\
\{a \mapsto \mbox{false}, c \mapsto \mbox{true}\} &amp; 0.7
\end{array}\]

<p>Therefore, the weight for the transition from $t = {a \mapsto \mbox{true}, b \mapsto \mbox{false}, c \mapsto \mbox{true}}$ to $t’ = {a \mapsto \mbox{true}, b \mapsto \mbox{false}, c \mapsto \mbox{true}}$ is:</p>

\[\log \frac{p(t'; x')q(t; u', x)}{p(t; x) q(t'; u, x')}
= \log \frac{q(t; u', x)}{q(t'; u, x')}
= \log \frac{0.3}{0.3} = 0\]

<p>Next, we consider $t’ = {a \mapsto \mbox{false}, c \mapsto \mbox{true}}$. In this case $u’ = {c \mapsto \mbox{true}}$. The internal proposal distribution in this case is:</p>

\[\begin{array}{l|l}
\mbox{Random choice map } t &amp; q(t; x, u')\\
\hline
\{a \mapsto \mbox{true}, b \mapsto \mbox{true}, c \mapsto \mbox{true}\} &amp; 0.3 \cdot 0.6\\
\{a \mapsto \mbox{true}, b \mapsto \mbox{false}, c \mapsto \mbox{true}\} &amp; 0.3 \cdot 0.4\\
\{a \mapsto \mbox{false}, c \mapsto \mbox{true}\} &amp; 0.7\\
\end{array}\]

<p>The weight for the transition from $t = {a \mapsto \mbox{true}, b \mapsto \mbox{false}, c \mapsto \mbox{true}}$ to $t’ = {a \mapsto \mbox{false}, c \mapsto \mbox{true}}$ is:</p>

\[\log \frac{p(t'; x')q(t; u', x)}{p(t; x) q(t'; u, x')}
= \log \frac{p(t'; x')}{p(t; x)} + \log \frac{q(t; u', x)}{q(t'; u, x')}
= \log \frac{0.7 \cdot 0.9}{0.3 \cdot 0.4 \cdot 0.2} + \log \frac{0.3 \cdot 0.4}{0.7}\]

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">log</span><span class="x">((</span><span class="mf">0.7</span> <span class="o">*</span> <span class="mf">0.9</span><span class="x">)</span><span class="o">/</span><span class="x">(</span><span class="mf">0.3</span> <span class="o">*</span> <span class="mf">0.4</span> <span class="o">*</span> <span class="mf">0.2</span><span class="x">))</span> <span class="o">+</span> <span class="n">log</span><span class="x">((</span><span class="mf">0.3</span> <span class="o">*</span> <span class="mf">0.4</span><span class="x">)</span><span class="o">/</span><span class="x">(</span><span class="mf">0.7</span><span class="x">))</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1.504077396776274
</code></pre></div></div>

<p>Now that we’ve done all this work, let’s check it against Gen.</p>

<p>Run the cell enough times to sample both of the transitions, and confirm that the weights match with our calculations:</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">trace</span><span class="x">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">generate</span><span class="x">(</span><span class="n">foo</span><span class="x">,</span> <span class="x">(</span><span class="mf">0.3</span><span class="x">,),</span> <span class="n">choicemap</span><span class="x">((</span><span class="o">:</span><span class="n">a</span><span class="x">,</span> <span class="nb">true</span><span class="x">),</span> <span class="x">(</span><span class="o">:</span><span class="n">b</span><span class="x">,</span> <span class="nb">false</span><span class="x">),</span> <span class="x">(</span><span class="o">:</span><span class="n">c</span><span class="x">,</span> <span class="nb">true</span><span class="x">)));</span>
<span class="x">(</span><span class="n">trace</span><span class="x">,</span> <span class="n">weight</span><span class="x">,</span> <span class="n">retdiff</span><span class="x">)</span> <span class="o">=</span> <span class="n">regenerate</span><span class="x">(</span><span class="n">trace</span><span class="x">,</span> <span class="x">(</span><span class="mf">0.3</span><span class="x">,),</span> <span class="x">(</span><span class="n">NoChange</span><span class="x">(),),</span> <span class="n">select</span><span class="x">(</span><span class="o">:</span><span class="n">a</span><span class="x">));</span>
<span class="n">display</span><span class="x">(</span><span class="n">get_choices</span><span class="x">(</span><span class="n">trace</span><span class="x">))</span>
<span class="n">println</span><span class="x">(</span><span class="s">"weight: </span><span class="si">$</span><span class="s">weight"</span><span class="x">);</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>│
├── :a : false
│
└── :c : true



weight: 1.504077396776274
</code></pre></div></div>

<p>Aren’t we glad this is automated by Gen!</p>

<h3 id="approaching-irreducibility">Approaching irreducibility</h3>

<p>Exercise: Draw a graph in which each random choice map $t$ where $p(t; x) &gt; 0$ is a node, and where there are directed edges from $t$ to $t’$ if applying <code class="language-plaintext highlighter-rouge">regenerate</code> to $t$ with selection ${a}$ can produce trace $t’$. Do the same for selections ${b}$ and ${c}$. What about selection ${a,b,c}$?</p>

</div>

</main><!-- /.container -->

<!-- Footer -->
<footer class="page-footer font-small blue pt-4">

  <!-- Copyright -->
  <div class="footer-copyright text-center py-3">© 2020 Copyright: The author(s).
  </div>
  <!-- Copyright -->

</footer>
<!-- Footer -->

<script
			  src="https://code.jquery.com/jquery-3.5.1.min.js"
			  integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0="
			  crossorigin="anonymous"></script>
    <!--<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>-->
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js" integrity="sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha384-B4gt1jrGC7Jh4AgTPSdUtOBvfO8shuf57BaghqFfPlYxofvL8/KUEfYiJOMMV+rV" crossorigin="anonymous"></script>
  </body>
</html>
